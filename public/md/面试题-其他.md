- H5新标签,css3新特性

  header,aside,main,footer,nav,section,dialog,figure（在里面定义一组媒体内容和它们的标题）；

  transition过渡，animation动画，transform形状转换，box-shadow阴影，border-image边框图片，border-radius边框圆角，linear-gradient()线性渐变，radial-gradient()镜像渐变，flex布局等。

- 浏览器的缓存策略

  在第一次请求成功后会将请求结果和请求标识存进浏览器缓存中，在以后的每次请求时会先尝试从缓存中查找该请求的结果和缓存标识。强缓存，不会向服务端发起请求，直接从缓存中读取资源。协商缓存，当强缓存没有命中后，浏览器会携带缓存标识向服务端发起请求，服务端根据请求标识决定是否使用缓存。缓存标识分为两种，一种是服务端资源的最后一次修改的时间，相关请求头为Last-Modified和If-Modified-Since；另一种为服务端根据资源内容生成的标识，相关请求头为Etag和If-None-Match

- 前端安全性问题

  xss攻击。用户输入的文本当中或者HTML标签当中插入了JS脚本进行攻击。用户输入的内容是不可信得，所以需要过滤用户输入的内容，将标签字符串进行转义。
  CSRF攻击（跨站请求伪造）。攻击盗用你的身份，以你的名义发送恶意请求。具体为用户C登录了安全的网站A，并拿到了A签发的验证信息存在Cookie中。C在没有登出的情况下访问了恶意网站B，B携带用户C的cookie向A发起了恶意请求，由于A的验证机制只认Cookie，不能区分该请求是C还是A发送的，所以受到了攻击。
  解决方案：1，在重要的请求前发送验证码验证身份。2，放弃cookie的验证机制，用户成功登陆后返回JWT生成的token，后续的每次请求都在请求头中携带该token，服务端在拦截器中先验证身份。

- Cookie和Session

  cookie是在客户端保持状态，验证信息都放在cookie中并保存在客户端，不安全，SCRF攻击
  session是在服务端保持状态，服务端生成并存储session，向客户端派发session id，用来后续检索session。客户量大了后影响服务器性能。
  token，无状态，服务端无需存储。用户账号密码验证成功后，JWT根据秘钥，用户信息和算法生成token，并派发到客户端，后续的请求在请求头中携带该token，服务端验证。

- 单向数据流和双向数据流

  单向流动的一般过程为用户访问view，view发出用户的交互action，在action中修改state数据源，随后触发更新view。其实无论是Vue还是React，在项目层面上都更提倡数据的单向流动，具体体现在React中props是只读的，Vue中也不提倡在子组件中修改props。Vuex和Redux状态管理器也是以一个全局单实例的模式进行管理的。数据单向流动的好处是所有数据的修改都是可记录的，可追踪的；所有数据只有一份，有唯一的入口和出口，增加了项目的稳定性和可预测性。 在Vue中的双向数据绑定只不过是在UI控件上提供了双向绑定的方式，在需要实时反映用户输入的场合比较方便，但同时增加了不可预测性，增加了调试的难度。

- 前端性能优化

  前端性能的优化可以从以下几个方面入手：1）减少HTTP请求次数：采用雪碧图，将小图标转成base64，用cdn托管,开启Gzip压缩，压缩css和js，合理利用浏览器的缓存策略，条件允许的话用单独的图片服务器。2）CSS层面上，尽量减少无用的css,提取公共部分；尽量减少重排和重绘；不要用Id和类选择器修改标签选择器，因为css的匹配是从右向左匹配的；少用@import引入css，破坏了资源并行下载。3）JS层面上多写出有效率的代码，适当的用变量去缓存多个属性的查找结果或dom获取；合理的使用switch case好于if esle;尽量少用for in 循环等。4）在项目中合理的使用webpack配置，实现路由懒加载，分割代码块，当路由被访问的时候再加载。给列表做缓存，图片懒加载等。

- 面向切面编程

  将一些系统性相关的编程工作如权限管理，日志记录和异常处理等单独提取出来，独立实现，在通过切面加入进系统，避免了在业务代码中混入很多系统相关的东西。

- 从输入URL到页面加载中间发生了什么

  1）DNS解析，找到域名对应的IP地址；会先查找浏览器自身缓存的NDS记录，没有命中会查找Hosts文件和操作系统缓存，没有命中会向域名解析服务器发起解析请求。2）建立TCP连接。3）建立HTTP请求。4）服务端处理请求，返回响应数据。5）浏览器解析请求，渲染页面。6）关闭连接。其中渲染页面也可继续细化，1）将HTML代码转成DOM，2）将CSS代码转成CSSOM，3）结合DOM和CSSOM，生成渲染树，里面包含了每个节点的视觉信息，4）重排，将所有节点进行平面合成，5）重绘，将布局绘制在屏幕上。

- MVVM

  MVVM是一种设计思想，我们可以在这种思想的指导下去架构我们的项目。Model是数据模型，可以在里面定义数据接口，操作业务逻辑；view是UI组件，负责将数据模型展示出来；ViewModel负责同步Model和View，这一过程是自动的，无需人为干涉。开发者只需关注业务逻辑，不需要操作DOM，不需要关注数据状态同步的问题。

- 跨域

  浏览器的同源策略要求协议，域名，端口号三者一致，非同源即跨域。跨域限制了Ajax请求不能发送，Dom和Js对象无法获得， cookie和localStorage无法读取。常用的跨域解决方案。1）CORS跨域资源共享，一般服务端去配置，前端无需任何操作，整个过程是浏览器自动完成的，项目中最常用的一种方式。2）Nginx反向代理，由于服务器间不存在同源策略，也就不存在跨域，通过Nginx配置一个代理服务器做跳板。3）Node中间层代理，http-proxy-middleware，原理同上。4）在Vue项目开发时，会通过webpack-dev-server开启服务，通过webpack配置开启代理实现跨域。5）在iframe间实现通信，由于iframe间存在跨域，解决其跨域的一个很好的方式就是使用window.postMessage()方法实现iframe间的跨域通信。

- 谈谈前后端分离的理解

  我们知道，最开始的网页开发是没有前端的概念的。随着用户对页面的交互要求越来越高，及Ajax的出现，原来的后端通过JSP模板来开发的模式不再适用，需要解耦。同时，Node的兴起，越来越多的工具开始出现，如包管理器，预编译其，打包工具，webpack等，使前端开发越来越工程化，模块化。成熟的前后端分离在设计，开发，测试，部署的各个环节都有体现。设计阶段前端需要考虑用什么框架，是否需要使用Node中间层，和后端约定接口模型等；开发阶段前后端独立开发，前端通过mock模拟数据；测试阶段前端可先独立测试页面，交互，或者组件的单元测试等；部署时也可独立部署，前后端可按照各自的版本规划开发上线。

- 正向代理和反向代理

  client proxy server （正向代理中，proxy和client同属于一个LAN，对server透明；反向代理中，proxy和sever同属于一个LAN，对client透明） 正向代理是给client做代理，客户端通过代理服务器去访问不能访问的网站，客户端需要做配置，知道代理服务器的ip地址和端口。（正向代理 是一个位于客户端和原始服务器之间的一个服务器，为了从原始服务器取的内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端。客户端需要进行一些设置才能使用正向代理） 用途：访问原来无法访问的资源（google） 可以做缓存，加速访问资源 对客户端访问授权，上网进行认证 代理可以记录用户访问记录，对外隐藏用户信息 反向代理是给原始服务器做代理，以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外表现就像原始服务器，客户端不需要任何配置就可以访问 用途：保证内网的安全（某些网站将代理作为公网访问地址，web服务器是内网） 负载均衡（通过反向代理服务器来优化网站的负载） 1、正向代理和反向代理 client proxy server （正向代理中，proxy和client同属于一个LAN，对server透明；反向代理中，proxy和sever同属于一个LAN，对client透明） 正向代理是给client做代理，客户端通过代理服务器去访问不能访问的网站，客户端需要做配置，知道代理服务器的ip地址和端口。（正向代理 是一个位于客户端和原始服务器之间的一个服务器，为了从原始服务器取的内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端。客户端需要进行一些设置才能使用正向代理） 用途：访问原来无法访问的资源（google） 可以做缓存，加速访问资源 对客户端访问授权，上网进行认证 代理可以记录用户访问记录，对外隐藏用户信息 反向代理是给原始服务器做代理，以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外表现就像原始服务器，客户端不需要任何配置就可以访问 用途：保证内网的安全（某些网站将代理作为公网访问地址，web服务器是内网） 负载均衡（通过反向代理服务器来优化网站的负载）

- token/session/cookie

  token: userId + 算法 + 密钥，服务端只创建token而不存储； 服务端验证token时只需要验证其算法和密钥； token由客户端存储，可以存储在cookie或者localStorage中； 每次请求都需要携带token，有header携带； 优点：无状态，可扩展；支持移动设备（小程序里不能使用session，但可以用token）；跨程序调用（可以提供可选的权限给第三方应用程序）；安全；用验证的计算时间获取服务器的存储空间； cookie: 仅仅是浏览器实现的一种数据存储功能，由服务器生成，发送给浏览器，浏览器把cookie以key,value的形式存到某个目录下的文件中，下一次请求同一个网站时会把该cookie发送给服务器； session： 服务器创建一个session后，会把session的ID号以cookie的形式传给浏览器，这样，浏览器再去方问服务器时，都会携带sessionId，（一般以cookie的方式携带），服务器找到对应的ID，生成携带用户信息的session，当一段时间没有用到该session时，服务端的session会被销毁； 服务器需要存储所有用户的sessionID，开销会越来越大，且限制了服务器的扩展能力（当用多个服务器时，不能保证每次的sessionID都发到对应的拂去其上）；


- http1.0和http2.0

  http超文本传输协议。带宽和延迟是影响网络请求的重要因素。一次TCP连接要经历三次握手和慢启动的过程，而http1.0被抱怨最多的就是连接无法复用，导致每次请求都经历三次握手和慢启动；对头阻塞的问题（服务器必须按照请求的顺序来响应，后续的请求的响应必须等到第一个响应结束后才能发送）导致带宽无法被充分利用。http2.0基于SPDY协议，是基于TCP协议的应用层协议。http2.0采用二进制分帧，即把报文全部换成二进制格式，被拆分成一个个二进制的帧。这些二进制帧不存在先后关系，因此也就不会排队等待，也就解决了http队头阻塞的问题。通信双方都可以给对方发送二进制帧，二进制帧双向传输的序列，叫做流。流的并发性可以使一个http2连接上同时发送多个帧，是实现多路复用的基础；流程双向性可以实现服务器推送；流的可设置优先级的特性可以实现请求的优先级。同时http2还实现了头部压缩。

- http和https

  http信息是明文传输。https在http下面增加了SSL安全套接层，加密传输更安全。


- 依赖注入

  它是面向对象编程下的一种设计原则，简而言之就是不需要自己手动去实例化依赖的类，由容器去解析依赖关系，实例化这些依赖的类，通过构造函数过接口的方式注入到需要这些依赖的类中去，实现解耦。


- 浏览器中的事件传播机制

  默认是从目标元素开始，冒泡执行（从里向外传播）；可以addEventListener()的第三个参数决定，默认是false，设置为true则在捕获阶段执行，会先触发外层元素的绑定事件。

  阻止冒泡，捕获：e.stopPropagation()，IE使用e.cancelBubble=true

  取消默认行为：e.preventDefault()，IE使用e.returnValue=false

- 开发中遇到的印象深刻的问题
  - 路由守卫死循环的问题：第三个参数next的使用问题，我们知道一定要调用这个函数来resolve这个钩子，否则会一直吊起。next()则不会再进入beforeEach。如果next('/login')则还会再进入beforeEach，而这个时候条件依然无法满足，再次进入next('/login')，所以会一直循环。
  - 微前端主框架登录后分发到子应用路径加载慢，需要优化。当时用的是location.replace()方法，不会在路由栈中留下历史记录，觉得设么问题。后来了解到这样改变url，效果类似于f5刷新，会重新加载所有的资源。后面使用的是飞冰框架提供的AppHistory.replace()。其实也是基于history.replaceState()

------

Vue

- 虚拟DOM

  虚拟DOM就是一个以JavaScript对象为基础的树，对象叫做VNode，包含标签tag，属性attrs和子元素对象children，用来描述节点信息。实际上是对真实DOM的抽象，最终这棵树映射到真实环境中，生成真实的DOM。 虚拟DOM的好处。真实操作DOM比较慢，而js运行效率高。当数据变更时，会对比新旧虚拟DOM树，找到真实需要更新的节点，在下一个事件循环中统一更新视图，最大限度的减少DOM操作，提高性能。

- vue双向数据绑定的原理

  1）将数据对象变得可观测，Vue会循环遍历data对象的所有属性，通过Object.definePropty将其转换为getter和setter来数据劫持（优化点，Object.freeze()）2)通过发布订阅模式，将所有依赖收集起来，一旦数据发生变化，统一通知依赖该数据的视图更新。3）更新DOM是异步执行的，侦听到数据变化后，Vue将开启一个队列，缓冲在同一事件循环中发生的所有数据变更，在下一个事件循环tick中更新。

- vue中在使用v-for渲染列表时的key的作用是什么

  概括的说key的主要作用就是为了高效准确的更新虚拟DOM。举个例子，用v-for渲染ABC三个列表，现在要在AB之间插入D，如果不加key或者key是index，则只有A复用之前的，DBC都需要重新渲染；而如果用数组中不会变化的那项比如Id作为key，则ABC都可以复用之前的，只有新增那项需要重新渲染。所以在需要保存列表的状态时，需要使用唯一的key值来准确的定位每一个列表项及复用自身的状态。另外，在Vue中，相同标签名元素的过渡切换时，也会使用key属性，目的是使Vue区分它们，否则只会替换内部属性而不会触发过渡。

- Vue项目中有什么遇到过难点分享一下啊

  开发中遇到的问题都即时解决掉了，经验总结出两条吧。1是我整理过一个Vue项目的代码规范，并在前端小组中推行。里面包括文件夹，单文件，props，事件名的命名风格，eslint的风格配置，还有一些最佳实践等等。2是要时不时的重读一遍文档，说不上那个新出的属性就会使你的代码实现更简洁。比如之前自定义弹窗组件时，都是通过value的prop属性和监听input事件来实现v-model，控制显隐。.sync修饰符出现后，子组件显示的触发一个更新事件，修改了一个prop值，会同步到父组件中，实现类似prop的双向绑定的功能。再比如当我们对elementUI的弹窗再封装时，同时又想保留原有的属性和事件，通过`v-bind="$attrs"`,`v-on="$listeners"`,同时将`inheritAttrs`设置为false即可实现。

- vuex

  vuex是一个专门为Vue应用程序开发的状态管理模式。它将组件间共享的状态抽取出来，一个全局单例模式管理。有唯一的数据源state，改变状态的唯一方式就是显示的commit一个mutation，方便我们跟踪每一个状态的变化，提高可预测性。


- 路由的hash模式和history模式

  \#及\#后面的内容成为hash，hash虽然在url中，但不被包括在http请求中，不会重新加载页面。

  history利用h5新特性提供的两个方法，pushState()和replaceState()可以对浏览器历史记录栈进行修改，如果匹配不到静态资源会返回404，所以一般需要提供一个404页面。


- $route和$router

  $route是路由信息对象，包括name,path,params,query等路由信息参数。$router是路由实例，提供路由的跳转方法，钩子函数等。


- 路由守卫用过吗

  使用过全局前置守卫beforeEach登录的拦截。先定义一个路由白名单，里面定义了不用登录就可以访问的页面路由，剩下的页面是需要登录成功后才可以访问的页面。在全局前置守卫中，如果可以获取到登录后的token，则直接next()resolve这个钩子，正常访问。如果获取不到token，则判断要访问的路由是不是在白名单中，在，则next()，不过不在，则next('/login')


- v-if和v-show的区别
  - v-if是真正的条件渲染，它会确保在切换的过程中，合适的销毁和重建内部的事件监听器和子组件；是惰性的，直到条件第一次为真是才开始渲染。
  - V-show是基于css属性display控制显隐；元素总是会被渲染；不适合在template标签上使用，不支持v-else。


- computed和watch的区别
  - computed基于他们的依赖进行缓存，只有依赖的数据发生了变化，才会重新计算；不支持异步，当有异步操作时，无法监听数据的变化。
  - watch不支持缓存，支持异步操作，监听的函数接收两个参数，第一个是最新的值，第二个是变化之前的值。


- spa单页面的理解，优缺点是什么？

  spa仅在web页面初始化的时候加载相应的HTML，js和css，一旦页面加载完成，spa不会再进行页面的重新加载，取而代之的是是利用路由机制实现html内容的替换。优点：内容的改变不需要重新加载整个页面，避免了不必要的跳转和重新渲染，用户体验好。缺点：初次加载耗时多；不利于SEO。

- Vue中父子组件生命周期的执行顺序

  常用钩子的简易版：父created->子created->子mounted->父mounted

  完整版加载渲染过程：父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted